# 哈希结构
主要三种: 数组, 集合(set), 映射(map)

## 集合set

| 集合          | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率   | 增删效率|
| --------      | ------  | ------- | --------        | --------    | -------   | --------  |
| set           | 红黑树  | 有序     | 否              | 否          | O(log n)  | O(log n)  |
| multiset      | 红黑树  | 有序     | 是              | 否          | O(log n)  | O(log n)  |
| unordered_set | 哈希表  | 无序     | 否              | 否          | O(1)-O(n) | O(1)-O(n) |

unordered_set底层实现为哈希表，set 和 multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。
O(n)是因为发生了哈希冲突（即多个元素被哈希到同一个桶中）的情况下，某个桶中的元素数量可能增多，导致查找、插入和删除操作需要遍历这个桶中的所有元素，从而在最坏情况下时间复杂度变为O(n)。

## 映射map
| 映射          | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值  | 查询效率 | 增删效率|
| --------      | ------  | ------- | --------        | --------     | ------- | -------- |
| map           | 红黑树  | key有序  | key不可以重复    | key不可以修改 | O(log n) | O(log n) |
| multimap      | 红黑树  | key有序  | key可以重复      | key不可以修改 | O(log n) | O(log n) |
| unordered_map | 哈希表  | key无序  | key不可以重复    | key不可以修改 | O(1)     | O(1) |

unordered_map 底层实现为哈希表，map 和 multimap 的底层实现是红黑树。同理，map 和 multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

## 注意
当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

虽然std::set和std::multiset 的底层实现基于红黑树而非哈希表，它们通过红黑树来索引和存储数据。不过给我们的使用方式，还是哈希法的使用方式，即依靠键（key）来访问值（value）。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。std::map也是一样的道理。