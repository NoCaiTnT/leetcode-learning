# 459 重复的子字符串
## 链接
https://leetcode.cn/problems/repeated-substring-pattern/description/

## 题目 
给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

## 示例
示例 1:
```
输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
```
示例 2:
```
输入: s = "aba"
输出: false
```
示例 3:
```
输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```

提示：

- 1 <= s.length <= 10e4
- s 由小写英文字母组成 

## 代码
```
#include<iostream>
#include<cstring>
using namespace std;

class Solution {
public:
	void getNext(int* next, string s) {
		int j = 0, slen = s.size();
		next[0] = 0;
		for(int i = 1; i < slen; i++) {
			while(j > 0 && s[j] != s[i]) {
				j = next[j-1];
			}
			if (s[j] == s[i]) {
				j++;
			}
			next[i] = j;
		}
	}
	
	int kmp(string main, string sub) {
		int mainlen = main.size(), sublen = sub.size();
		int *next = new int[sublen];
		getNext(next, sub);
		int j = 0;
		for(int i = 0; i < mainlen; i++) {
			while(j > 0 && main[i] != sub[j]) {
				j = next[j-1];
			}
			if (main[i] == sub[j])
				j++;
			if (j == sublen)
				return i - sublen + 1;
		}
		return -1;
	}
	
    bool repeatedSubstringPattern(string s) {
		string t1(s.begin()+1, s.end());
		string t2(s.begin(), s.end()-1);
		string t = t1 + t2;
		if(kmp(t, s) != -1) return true;
		else return false;
    }
};

int main() {
	Solution solution;
	string s = "ababba";
	auto res = solution.repeatedSubstringPattern(s);
	cout << res;
	return 0;
}
```